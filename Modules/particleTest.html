<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Teleporter Dash Particle Test</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
    body {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      background: #222;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: manipulation;
    }
    #gameContainer {
      width: 80%;
      max-width: 800px;
      height: 400px;
      margin-top: 20px;
      border: 2px solid #555;
      overflow: hidden;
      position: relative;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    button {
      background: #00ff80;
      color: #222;
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #00cc66;
    }
    #effectControls, #blockControls {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      width: 80%;
      max-width: 800px;
    }
    h2 {
      color: #00ff80;
      text-align: center;
      margin-top: 10px;
    }
    .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    .control-label {
      width: 100%;
      color: #ccc;
      font-size: 14px;
      margin-bottom: 5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }
    .debug-panel {
      background: rgba(0, 0, 0, 0.7);
      color: #00ff80;
      font-family: monospace;
      padding: 10px;
      margin-top: 20px;
      width: 80%;
      max-width: 800px;
      height: 150px;
      overflow-y: auto;
      border-radius: 8px;
    }
  </style>
  <script src="External Modules/pixi.js"></script>
  <script src="External Modules/pixi-filters.js"></script>
  <script>
    window.addEventListener('load', () => {
      if (typeof PIXI === 'undefined') {
        console.error('PixiJS failed to load');
      } else {
        console.log('PixiJS loaded, version:', PIXI.version || 'unknown');
        console.log('PIXI.Application available:', !!PIXI.Application);
        console.log('PIXI.filters available:', !!PIXI.filters?.GlowFilter);
      }
    });
  </script>
</head>
<body>
  <h1>Teleporter Dash Particle Test</h1>
  <div id="gameContainer"></div>
  
  <div id="effectControls">
    <h2>Particle Effects</h2>
    <div class="control-group">
      <div class="control-label">Trigger Effect:</div>
      <button id="sparkleBtn">Sparkle</button>
      <button id="waveBtn">Wave</button>
      <button id="shockBtn">Shock</button>
      <button id="explosionBtn">Explosion</button>
    </div>
    
    <div class="control-group">
      <div class="control-label">Particle Count: <span id="particleCountValue">10</span></div>
      <input type="range" id="particleCount" min="1" max="50" value="10">
    </div>
    
    <div class="control-group">
      <div class="control-label">Particle Size: <span id="particleSizeValue">5</span></div>
      <input type="range" id="particleSize" min="1" max="20" value="5">
    </div>
    
    <div class="control-group">
      <div class="control-label">Particle Lifetime: <span id="particleLifetimeValue">1.0</span></div>
      <input type="range" id="particleLifetime" min="0.1" max="5" step="0.1" value="1.0">
    </div>
  </div>
  
  <div id="blockControls">
    <h2>Test Controls</h2>
    <div class="control-group">
      <button id="resetBtn">Reset Scene</button>
      <button id="randomColorsBtn">Random Colors</button>
      <button id="allEffectsBtn">Trigger All Effects</button>
    </div>
  </div>
  
  <div class="debug-panel" id="debugOutput"></div>
  
  <script type="module">
    import { log, warn, error, debug as originalDebug, verbose, setLogLevel } from './logManager.js';
    import { RenderEngine } from './renderEngine.js';
    import { ParticleSystem } from './effectEngine.js';
    import { hexToRGB, rgbToHex, hexToNumber } from './colorUtils.js';
    import AudioManager from './audioManager.js';
    
    // Set log level
    setLogLevel('debug');
    
    // Initialize components
    let app;
    let renderEngine;
    let particleSystem;
    let audioManager = null;
    let testBlocks = [];
    
    // Save parameter refs
    let particleSize = 5;
    let particleCount = 10;
    let particleLifetime = 1.0;
    
    // Setup debug output
    const debugOutput = document.getElementById('debugOutput');
    function addDebugMessage(message) {
      const msgElement = document.createElement('div');
      msgElement.textContent = `[${new Date().toISOString().substr(11, 8)}] ${message}`;
      debugOutput.appendChild(msgElement);
      debugOutput.scrollTop = debugOutput.scrollHeight;
    }
    
    // Override the debug function to also output to our panel
    let debug = function(category, message, ...args) {
      originalDebug(category, message, ...args);
      addDebugMessage(`[${category}] ${message}`);
    };
    
    // Initialize PIXI
    async function initPixi() {
      debug('particleTest', 'Initializing PIXI application');
      
      try {
        // Get the game container
        const container = document.getElementById('gameContainer');
        if (!container) {
          error('particleTest', 'Game container not found');
          return;
        }
        
        // Set container dimensions
        container.style.width = '800px';
        container.style.height = '400px';
        container.style.position = 'relative';
        
        // Create the Pixi application first
        app = new window.PIXI.Application();
        
        // Initialize with settings
        await app.init({
          width: 800,
          height: 400,
          backgroundColor: 0x222222,
          resolution: 1,
          autoDensity: false
        });
        
        // Ensure the stage is properly set up
        if (!app.stage) {
          app.stage = new window.PIXI.Container();
          app.stage.sortableChildren = true;
          app.stage.visible = true;
          app.stage.alpha = 1;
        }
        
        // Set explicit canvas dimensions
        app.renderer.resize(800, 400);
        app.canvas.width = 800;
        app.canvas.height = 400;
        
        // Set CSS dimensions to maintain proper aspect ratio
        app.canvas.style.width = '800px';
        app.canvas.style.height = '400px';
        
        // Set renderer resolution explicitly
        app.renderer.resolution = 1;
        
        // Add the canvas to the container
        container.appendChild(app.canvas);
        debug('particleTest', 'Canvas appended to container');
        debug('particleTest', `Canvas element: ${app.canvas.tagName}, size: ${app.canvas.width}x${app.canvas.height}`);
        
        // Initialize audio manager
        try {
          audioManager = new AudioManager();
          await audioManager.initialize();
          debug('particleTest', 'AudioManager initialized');
        } catch (err) {
          error('particleTest', 'Failed to initialize AudioManager:', err);
          // Proceed without audio
          audioManager = null;
        }
        
        // Initialize render engine
        renderEngine = new RenderEngine(app, 32);
        
        // Set audio manager if available
        if (audioManager) {
          renderEngine.setAudioManager(audioManager);
        }
        
        // Initialize particle system with render engine's container
        particleSystem = new ParticleSystem(renderEngine.container);
        
        // Add particle system container to render engine's container
        renderEngine.container.addChild(particleSystem.container);
        
        // Start the PIXI ticker
        app.ticker.add((delta) => {
          if (particleSystem) {
            particleSystem.update(delta);
          }
        });
        
        // Ensure render engine container is properly set up
        if (renderEngine.container) {
          renderEngine.container.sortableChildren = true;
          renderEngine.container.visible = true;
          renderEngine.container.alpha = 1;
          
          // Add render engine container to stage
          app.stage.addChild(renderEngine.container);
          
          // Add debug shape to test visibility
          const debugShape = new window.PIXI.Graphics();
          debugShape.fill({ color: 0xFF0000, alpha: 1 });
          debugShape.rect(0, 0, 50, 50);
          renderEngine.container.addChild(debugShape);
        }
        
        debug('particleTest', 'Initialization complete');
        debug('particleTest', `Canvas dimensions: ${app.canvas.width}x${app.canvas.height}`);
        debug('particleTest', `Container dimensions: ${container.offsetWidth}x${container.offsetHeight}`);
      } catch (err) {
        error('particleTest', 'Error initializing PIXI:', err);
        throw err; // Re-throw to be caught by the caller
      }
    }
    
    // Create test blocks for particle effects
    function createTestBlocks() {
      debug('particleTest', 'Creating test blocks');
      
      // Clear existing blocks
      if (renderEngine.blockContainer) {
        renderEngine.blockContainer.destroy({ children: true });
        renderEngine.blockContainer = null;
      }
      
      // Reset particle system
      if (particleSystem) {
        particleSystem.reset();
      }

      if (!renderEngine || !renderEngine.container || !app) {
        error('particleTest', 'Render engine or app not initialized');
        return;
      }
      

      // Clear existing blocks
      testBlocks.forEach(block => {
        if (block.sprite && block.sprite.parent) {
          block.sprite.parent.removeChild(block.sprite);
          block.sprite.destroy(); // Destroy the sprite to free resources
        }
      });
      testBlocks = [];

      // Create or reset block container
      if (!renderEngine.blockContainer) {
        renderEngine.blockContainer = new window.PIXI.Container();
        renderEngine.blockContainer.sortableChildren = true;
        renderEngine.blockContainer.visible = true;
        renderEngine.blockContainer.alpha = 1;
        renderEngine.blockContainer.zIndex = 1;
        
        // Set proper bounds and position
        renderEngine.blockContainer.x = 0;
        renderEngine.blockContainer.y = 0;
        renderEngine.blockContainer.width = app.canvas.width;
        renderEngine.blockContainer.height = app.canvas.height;
        
        renderEngine.container.addChild(renderEngine.blockContainer);
      }

      const effectTypes = ['sparkle', 'wave', 'shock', 'explosion'];
      const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0x00FFFF, 0xFF00FF, 0xFFFFFF, 0xFF8800];
      const blockSize = 32;
      const padding = 20;
      const blocksPerRow = 4;

      const startX = (app.canvas.width - ((blockSize + padding) * blocksPerRow - padding)) / 2;
      const startY = 80;

      for (let i = 0; i < effectTypes.length; i++) {
        const effectType = effectTypes[i];

        for (let j = 0; j < blocksPerRow; j++) {
          const color = colors[i * blocksPerRow + j] || colors[0];
          const sprite = new window.PIXI.Graphics();

          // Use PIXI v8's new drawing methods
          if (effectType === 'sparkle') {
            sprite.beginPath();
            sprite.moveTo(0, 0);
            sprite.lineTo(blockSize, 0);
            sprite.lineTo(blockSize, blockSize);
            sprite.lineTo(0, blockSize);
            sprite.closePath();
            sprite.fill({ color, alpha: 1 });
          } else if (effectType === 'wave') {
            sprite.beginPath();
            sprite.arc(blockSize / 2, blockSize / 2, blockSize / 2, 0, Math.PI * 2);
            sprite.closePath();
            sprite.fill({ color, alpha: 1 });
          } else if (effectType === 'shock') {
            sprite.beginPath();
            sprite.moveTo(blockSize / 2, blockSize / 2);
            for (let i = 0; i < 5; i++) {
              const angle = (i / 5) * Math.PI * 2;
              const radius = blockSize / 2;
              const x = blockSize / 2 + Math.cos(angle) * radius;
              const y = blockSize / 2 + Math.sin(angle) * radius;
              sprite.lineTo(x, y);
            }
            sprite.closePath();
            sprite.fill({ color, alpha: 1 });
          } else {
            sprite.beginPath();
            sprite.moveTo(blockSize / 2, 0);
            sprite.lineTo(blockSize, blockSize / 2);
            sprite.lineTo(blockSize / 2, blockSize);
            sprite.lineTo(0, blockSize / 2);
            sprite.closePath();
            sprite.fill({ color, alpha: 1 });
          }

          sprite.x = startX + j * (blockSize + padding);
          sprite.y = startY + i * (blockSize + padding);

          // Set sprite properties before adding
          sprite.visible = true;
          sprite.alpha = 1;
          sprite.sortableChildren = true;
          sprite.interactive = true;
          sprite.buttonMode = true;
          
          // Add sprite to block container
          renderEngine.blockContainer.addChild(sprite);
          
          // Debug logging
          debug('particleTest', `Added sprite to block container: ${sprite.children.length}`);
          debug('particleTest', `Block container children count: ${renderEngine.blockContainer.children.length}`);
          debug('particleTest', `Sprite position: ${sprite.x}, ${sprite.y}`);
          debug('particleTest', `Sprite bounds: ${sprite.getBounds().width}x${sprite.getBounds().height}`);

          testBlocks.push({
            sprite: sprite,
            effect: effectType,
            color: color
          });
        }
      }

      debug('particleTest', `Created ${testBlocks.length} test blocks`);
      debug('particleTest', `Block container children: ${renderEngine.blockContainer.children.length}`);
      debug('particleTest', `Main container children: ${renderEngine.container.children.length}`);
      debug('particleTest', `Stage children: ${app.stage.children.length}`);
      debug('particleTest', `Block container visible: ${renderEngine.blockContainer.visible}`);
      debug('particleTest', `Block container alpha: ${renderEngine.blockContainer.alpha}`);
      debug('particleTest', `Block container zIndex: ${renderEngine.blockContainer.zIndex}`);
    }   
    
    // Initialize UI controls
    function initControls() {
      // Initialize all buttons
      const buttons = document.querySelectorAll('button');
      buttons.forEach(button => {
        button.disabled = true; // Disable until initialization is complete
      });
      
      // Effect buttons
      document.getElementById('sparkleBtn').addEventListener('click', () => triggerEffect('sparkle'));
      document.getElementById('waveBtn').addEventListener('click', () => triggerEffect('wave'));
      document.getElementById('shockBtn').addEventListener('click', () => triggerEffect('shock'));
      document.getElementById('explosionBtn').addEventListener('click', () => triggerEffect('explosion'));
      
      // Test controls
      document.getElementById('resetBtn').addEventListener('click', resetScene);
      document.getElementById('randomColorsBtn').addEventListener('click', randomizeColors);
      document.getElementById('allEffectsBtn').addEventListener('click', triggerAllEffects);
      
      // Sliders
      const particleCountSlider = document.getElementById('particleCount');
      const particleCountValue = document.getElementById('particleCountValue');
      particleCountSlider.addEventListener('input', () => {
        particleCount = parseInt(particleCountSlider.value);
        particleCountValue.textContent = particleCount;
      });
      
      const particleSizeSlider = document.getElementById('particleSize');
      const particleSizeValue = document.getElementById('particleSizeValue');
      particleSizeSlider.addEventListener('input', () => {
        particleSize = parseInt(particleSizeSlider.value);
        particleSizeValue.textContent = particleSize;
      });
      
      const particleLifetimeSlider = document.getElementById('particleLifetime');
      const particleLifetimeValue = document.getElementById('particleLifetimeValue');
      particleLifetimeSlider.addEventListener('input', () => {
        particleLifetime = parseFloat(particleLifetimeSlider.value);
        particleLifetimeValue.textContent = particleLifetime.toFixed(1);
      });
      
      // Enable buttons after initialization
      buttons.forEach(button => {
        button.disabled = false;
      });
    }

    // Update particle size in the system
    function updateParticleSize() {
      // This function will be used to update particle size when we implement dynamic particle size
      debug('particleTest', `Updated particle size to ${particleSize}`);
    }
    
    // Update particle lifetime in the system
    function updateParticleLifetime() {
      // This function will be used to update particle lifetime when we implement dynamic particle lifetime
      debug('particleTest', `Updated particle lifetime to ${particleLifetime}`);
    }
    
    // Trigger a specific effect on all matching blocks
    function triggerEffect(effectType) {
      debug('particleTest', `Triggering ${effectType} effect`);
      
      if (!particleSystem) {
        error('particleTest', 'Particle system not initialized');
        return;
      }
      
      // Find a block with the matching effect type
      const block = testBlocks.find(b => b.effect === effectType);
      if (!block) {
        error('particleTest', `No block found with effect type: ${effectType}`);
        return;
      }
      
      try {
        if (effectType === 'explosion') {
          particleSystem.createExplosion(block.sprite, block.color, particleCount);
        } else {
          // Emit multiple particles
          for (let i = 0; i < particleCount; i++) {
            particleSystem.emit(block.sprite, effectType, 1 + Math.random(), block.color);
          }
        }
        
        // Play sound for effect
        if (audioManager) {
          switch(effectType) {
            case 'explosion':
              audioManager.playDeathSound();
              break;
            case 'sparkle':
            case 'wave':
              audioManager.playJumpSound();
              break;
            case 'shock':
              audioManager.playCompletionSound();
              break;
          }
        }
        
        debug('particleTest', `Successfully triggered ${effectType} effect`);
      } catch (err) {
        error('particleTest', `Error triggering ${effectType} effect:`, err);
      }
    }
    
    // Trigger all effects
    function triggerAllEffects() {
      debug('particleTest', 'Triggering all effects');
      
      const effectTypes = ['sparkle', 'wave', 'shock', 'explosion'];
      effectTypes.forEach(effect => {
        setTimeout(() => triggerEffect(effect), Math.random() * 500);
      });
    }
    
    // Reset the scene
    function resetScene() {
      debug('particleTest', 'Resetting scene');
      
      try {
        // Reset audio if available
        if (audioManager) {
          audioManager.reset();
        }
        
        // Reset particle system if available
        if (particleSystem && particleSystem.reset) {
          particleSystem.reset();
        }
        
        // Recreate test blocks
        createTestBlocks();
      } catch (err) {
        error('particleTest', 'Error resetting scene:', err);
      }
    }
    
    // Randomize block colors
    function randomizeColors() {
      debug('particleTest', 'Randomizing block colors');
      
      testBlocks.forEach(block => {
        // Generate random color
        const color = Math.floor(Math.random() * 0xFFFFFF);
        
        // Update block color
        block.sprite.clear();
        block.sprite.fill({ color, alpha: 1 });
        
        // Redraw shape based on effect type
        if (block.effect === 'sparkle') {
          block.sprite.rect(0, 0, 32, 32);
        } else if (block.effect === 'wave') {
          block.sprite.circle(16, 16, 16);
        } else if (block.effect === 'shock') {
          block.sprite.star(16, 16, 5, 16, 8);
        } else {
          block.sprite.poly([16, 0, 32, 16, 16, 32, 0, 16]);
        }
        
        // Update color reference
        block.color = color;
      });
    }
    
    // Initialize when document is ready
    window.addEventListener('load', async () => {
      // Wait for PIXI to be available
      if (!window.PIXI) {
        error('particleTest', 'PIXI.js is not loaded');
        addDebugMessage('ERROR: PIXI.js is not loaded. Make sure to include PIXI.js in your HTML.');
        return;
      }
      
      try {
        // Initialize PIXI
        await initPixi();
        
        // Create test blocks
        createTestBlocks();
        
        // Initialize UI controls
        initControls();
      } catch (err) {
        error('particleTest', 'Error initializing test:', err);
        addDebugMessage(`ERROR: Failed to initialize test: ${err.message}`);
      }
    });
  </script>
</body>
</html>
